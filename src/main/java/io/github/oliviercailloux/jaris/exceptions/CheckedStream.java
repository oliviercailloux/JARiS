package io.github.oliviercailloux.jaris.exceptions;

import com.google.common.collect.ImmutableList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * An equivalent to Java {@link Stream} which allows for functional interfaces that may throw
 * checked exceptions; designed for people who do not like sneaky-throws.
 * <p>
 * The following popular SO questions mention several libraries that deal with the “streams and
 * checked exceptions” issue, but (at the time of writing) every library that I found there sneaky
 * throw, apart from
 * <a href= "https://github.com/JeffreyFalgout/ThrowingStream/">ThrowingStream</a>.
 * </p>
 * <ul>
 * <li><a href="https://stackoverflow.com/questions/23548589">Java 8: How do I work with exception
 * throwing methods in streams?</a></li>
 * <li><a href="https://stackoverflow.com/questions/19757300">Java 8: Lambda-Streams, Filter by
 * Method with Exception</a></li>
 * <li><a href="https://stackoverflow.com/questions/30117134">Aggregate runtime exceptions in Java 8
 * streams</a></li>
 * <li><a href="https://stackoverflow.com/questions/27644361">How can I throw CHECKED exceptions
 * from inside Java 8 streams?</a></li>
 * </ul>
 * <p>
 * This approach is heavily inspired by
 * <a href= "https://github.com/JeffreyFalgout/ThrowingStream/">ThrowingStream</a>; some differences
 * are discussed <a href="https://github.com/JeffreyFalgout/ThrowingStream/issues/3">here</a>.
 * </p>
 * <p>
 * The Javadoc for methods also present in {@code Stream} (most methods of this class) has been
 * copied from the {@code Stream} analog, with minor modifications.
 * </p>
 *
 * @param <T> the type of the stream elements
 * @param <X> an exception type that functionals used with this stream may throw, and that terminal
 *        operations on this stream may throw
 * @see Stream
 */
public interface CheckedStream<T, X extends Exception> {

  /**
   * Returns a checked stream wrapping the given stream.
   * <p>
   * The returned stream will behave as the delegate one except that it accepts functionals that
   * declare checked exceptions. The returned stream throws, on terminal operations, any exception
   * thrown by a functional operation during the stream operations.
   * </p>
   *
   * @param <T> the type of the stream elements
   * @param <X> an exception type that functionals used with the returned stream may throw, and
   *        therefore, that terminal operations on the returned stream may throw
   * @param delegate the stream executing operations
   * @return a checked stream delegating to the given stream
   */
  public static <T, X extends Exception> CheckedStream<T, X> wrapping(Stream<T> delegate) {
    return CheckedStreamImpl.wrapping(delegate);
  }

  /**
   * Returns a checked stream wrapping the stream produced by {@code collection.stream()}.
   * <p>
   * The returned stream will behave as the delegate one except that it accepts functionals that
   * declare checked exceptions. The returned stream throws, on terminal operations, any exception
   * thrown by a functional operation during the stream operations.
   * </p>
   *
   * @param <T> the type of the stream elements
   * @param <X> an exception type that functionals used with the returned stream may throw, and
   *        therefore, that terminal operations on the returned stream may throw
   * @param collection the source
   * @return a checked stream using the given collection as source
   */
  public static <T, X extends Exception> CheckedStream<T, X> from(Collection<T> collection) {
    return wrapping(collection.stream());
  }

  /**
   * Returns an infinite sequential unordered checked stream where each element is generated by the
   * provided {@code Throwing.Supplier}. This is suitable for generating constant streams, streams
   * of random elements, etc.
   * <p>
   * The returned stream accepts functionals that declare checked exceptions. The returned stream
   * throws, on terminal operations, any exception thrown by a functional operation during the
   * stream operations (including by the given generator).
   * </p>
   *
   * @param <T> the type of stream elements
   * @param <X> an exception type that functionals used with the returned stream may throw, and
   *        therefore, that terminal operations on the returned stream may throw
   * @param generator the {@code Throwing.Supplier} of generated elements
   * @return a new infinite sequential unordered {@code CheckedStream}
   * @see Stream#generate(Supplier)
   */
  public static <T, X extends Exception> CheckedStream<T, X>
      generate(Throwing.Supplier<? extends T, ? extends X> generator) {
    return CheckedStreamImpl.generate(generator);
  }

  /**
   * Returns a checked stream consisting of the distinct elements (according to
   * {@link Object#equals(Object)}) of this stream.
   *
   * <p>
   * For ordered streams, the selection of distinct elements is stable (for duplicated elements, the
   * element appearing first in the encounter order is preserved.) For unordered streams, no
   * stability guarantees are made.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @apiNote Preserving stability for {@code distinct()} in parallel pipelines is relatively
   *          expensive (requires that the operation act as a full barrier, with substantial
   *          buffering overhead), and stability is often not needed. Using an unordered stream
   *          source (such as {@link #generate(Supplier)}) or removing the ordering constraint with
   *          {@link #unordered()} may result in significantly more efficient execution for
   *          {@code distinct()} in parallel pipelines, if the semantics of your situation permit.
   *          If consistency with encounter order is required, and you are experiencing poor
   *          performance or memory utilization with {@code distinct()} in parallel pipelines,
   *          switching to sequential execution with {@link #sequential()} may improve performance.
   *
   * @see Stream#distinct()
   */
  CheckedStream<T, X> distinct();

  /**
   * Returns, if this stream is ordered, a checked stream consisting of the remaining elements of
   * this stream after dropping the longest prefix of elements that match the given predicate.
   * Otherwise returns, if this stream is unordered, a stream consisting of the remaining elements
   * of this stream after dropping a subset of elements that match the given predicate.
   *
   * <p>
   * If this stream is ordered then the longest prefix is a contiguous sequence of elements of this
   * stream that match the given predicate. The first element of the sequence is the first element
   * of this stream, and the element immediately following the last element of the sequence does not
   * match the given predicate.
   *
   * <p>
   * If this stream is unordered, and some (but not all) elements of this stream match the given
   * predicate, then the behavior of this operation is nondeterministic; it is free to drop any
   * subset of matching elements (which includes the empty set).
   *
   * <p>
   * Independent of whether this stream is ordered or unordered if all elements of this stream match
   * the given predicate then this operation drops all elements (the result is an empty stream), or
   * if no elements of the stream match the given predicate then no elements are dropped (the result
   * is the same as the input).
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @implSpec The default implementation obtains the {@link #spliterator() spliterator} of this
   *           stream, wraps that spliterator so as to support the semantics of this operation on
   *           traversal, and returns a new stream associated with the wrapped spliterator. The
   *           returned stream preserves the execution characteristics of this stream (namely
   *           parallel or sequential execution as per {@link #isParallel()}) but the wrapped
   *           spliterator may choose to not support splitting. When the returned stream is closed,
   *           the close handlers for both the returned and this stream are invoked.
   *
   * @apiNote While {@code dropWhile()} is generally a cheap operation on sequential stream
   *          pipelines, it can be quite expensive on ordered parallel pipelines, since the
   *          operation is constrained to return not just any valid prefix, but the longest prefix
   *          of elements in the encounter order. Using an unordered stream source (such as
   *          {@link #generate(Supplier)}) or removing the ordering constraint with
   *          {@link #unordered()} may result in significant speedups of {@code dropWhile()} in
   *          parallel pipelines, if the semantics of your situation permit. If consistency with
   *          encounter order is required, and you are experiencing poor performance or memory
   *          utilization with {@code dropWhile()} in parallel pipelines, switching to sequential
   *          execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements to determine the longest prefix of elements.
   * @return the new stream
   * @see Stream#dropWhile(Predicate)
   */
  CheckedStream<T, X> dropWhile(Throwing.Predicate<? super T, ? extends X> predicate);

  /**
   * Returns, if this stream is ordered, a checked stream consisting of the longest prefix of
   * elements taken from this stream that match the given predicate. Otherwise returns, if this
   * stream is unordered, a stream consisting of a subset of elements taken from this stream that
   * match the given predicate.
   *
   * <p>
   * If this stream is ordered then the longest prefix is a contiguous sequence of elements of this
   * stream that match the given predicate. The first element of the sequence is the first element
   * of this stream, and the element immediately following the last element of the sequence does not
   * match the given predicate.
   *
   * <p>
   * If this stream is unordered, and some (but not all) elements of this stream match the given
   * predicate, then the behavior of this operation is nondeterministic; it is free to take any
   * subset of matching elements (which includes the empty set).
   *
   * <p>
   * Independent of whether this stream is ordered or unordered if all elements of this stream match
   * the given predicate then this operation takes all elements (the result is the same as the
   * input), or if no elements of the stream match the given predicate then no elements are taken
   * (the result is an empty stream).
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate
   * operation</a>.
   *
   * @apiNote While {@code takeWhile()} is generally a cheap operation on sequential stream
   *          pipelines, it can be quite expensive on ordered parallel pipelines, since the
   *          operation is constrained to return not just any valid prefix, but the longest prefix
   *          of elements in the encounter order. Using an unordered stream source (such as
   *          {@link #generate(Supplier)}) or removing the ordering constraint with
   *          {@link #unordered()} may result in significant speedups of {@code takeWhile()} in
   *          parallel pipelines, if the semantics of your situation permit. If consistency with
   *          encounter order is required, and you are experiencing poor performance or memory
   *          utilization with {@code takeWhile()} in parallel pipelines, switching to sequential
   *          execution with {@link #sequential()} may improve performance.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements to determine the longest prefix of elements.
   * @return the new stream
   * @see Stream#takeWhile(Predicate)
   */
  CheckedStream<T, X> takeWhile(Throwing.Predicate<? super T, ? extends X> predicate);

  /**
   * Returns a checked stream consisting of the elements of this stream that match the given
   * predicate.
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to each
   *        element to determine if it should be included
   * @return the new stream
   * @see Stream#filter(Predicate)
   */
  CheckedStream<T, X> filter(Throwing.Predicate<? super T, ? extends X> predicate);

  /**
   * Returns a checked stream consisting of the results of replacing each element of this stream
   * with the contents of a mapped stream produced by applying the provided mapping function to each
   * element. Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its
   * contents have been placed into this stream. (If a mapped stream is {@code null} an empty stream
   * is used, instead.)
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * @apiNote The {@code flatMap()} operation has the effect of applying a one-to-many
   *          transformation to the elements of the stream, and then flattening the resulting
   *          elements into a new stream.
   *
   *          <p>
   *          <b>Examples.</b>
   *
   *          <p>
   *          If {@code orders} is a stream of purchase orders, and each purchase order contains a
   *          collection of line items, then the following produces a stream containing all the line
   *          items in all the orders:
   *
   *          <pre>
   * {@code orders.flatMap(order -> order.getLineItems().stream());}
   *          </pre>
   *
   *          <p>
   *          If {@code path} is the path to a file, then the following produces a stream of the
   *          {@code words} contained in that file:
   *
   *          <pre>
   *          {@code
   *     Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);
   *     Stream<String> words = lines.flatMap(line -> Stream.of(line.split(" +")));
   * }
   *          </pre>
   *
   *          The {@code mapper} function passed to {@code flatMap} splits a line, using a simple
   *          regular expression, into an array of words, and then creates a stream of words from
   *          that array.
   *
   * @param <R> The element type of the new stream
   * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function to apply to each
   *        element which produces a stream of new values
   * @return the new stream
   * @see Stream#flatMap(Function)
   */
  <R> CheckedStream<R, X>
      flatMap(Throwing.Function<? super T, ? extends Stream<? extends R>, ? extends X> mapper);

  /**
   * Returns a checked stream consisting of the elements of this stream, truncated to be no longer
   * than {@code maxSize} in length.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate
   * operation</a>.
   *
   * @apiNote While {@code limit()} is generally a cheap operation on sequential stream pipelines,
   *          it can be quite expensive on ordered parallel pipelines, especially for large values
   *          of {@code maxSize}, since {@code limit(n)} is constrained to return not just any
   *          <em>n</em> elements, but the <em>first n</em> elements in the encounter order. Using
   *          an unordered stream source (such as {@link #generate(Supplier)}) or removing the
   *          ordering constraint with {@link #unordered()} may result in significant speedups of
   *          {@code limit()} in parallel pipelines, if the semantics of your situation permit. If
   *          consistency with encounter order is required, and you are experiencing poor
   *          performance or memory utilization with {@code limit()} in parallel pipelines,
   *          switching to sequential execution with {@link #sequential()} may improve performance.
   *
   * @param maxSize the number of elements the stream should be limited to
   * @return the new stream
   * @throws IllegalArgumentException if {@code maxSize} is negative
   * @see Stream#limit(long)
   */
  CheckedStream<T, X> limit(long maxSize);

  /**
   * Returns a checked stream consisting of the results of applying the given function to the
   * elements of this stream.
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * @param <R> The element type of the new stream
   * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function to apply to each
   *        element
   * @return the new stream
   * @see Stream#map(Function)
   */
  <R> CheckedStream<R, X> map(Throwing.Function<? super T, ? extends R, ? extends X> mapper);

  /**
   * Returns a checked stream consisting of the remaining elements of this stream after discarding
   * the first {@code n} elements of the stream. If this stream contains fewer than {@code n}
   * elements then an empty stream will be returned.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @apiNote While {@code skip()} is generally a cheap operation on sequential stream pipelines, it
   *          can be quite expensive on ordered parallel pipelines, especially for large values of
   *          {@code n}, since {@code skip(n)} is constrained to skip not just any <em>n</em>
   *          elements, but the <em>first n</em> elements in the encounter order. Using an unordered
   *          stream source (such as {@link #generate(Supplier)}) or removing the ordering
   *          constraint with {@link #unordered()} may result in significant speedups of
   *          {@code skip()} in parallel pipelines, if the semantics of your situation permit. If
   *          consistency with encounter order is required, and you are experiencing poor
   *          performance or memory utilization with {@code skip()} in parallel pipelines, switching
   *          to sequential execution with {@link #sequential()} may improve performance.
   *
   * @param n the number of leading elements to skip
   * @return the new stream
   * @throws IllegalArgumentException if {@code n} is negative
   * @see Stream#skip(long)
   */
  CheckedStream<T, X> skip(long n);

  /**
   * Returns a checked stream consisting of the elements of this stream, sorted according to natural
   * order. If the elements of this stream are not {@code Comparable}, a
   * {@code java.lang.ClassCastException} may be thrown when the terminal operation is executed.
   *
   * <p>
   * For ordered streams, the sort is stable. For unordered streams, no stability guarantees are
   * made.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @return the new stream
   * @see Stream#sorted()
   */
  CheckedStream<T, X> sorted();

  /**
   * Returns a checked stream consisting of the elements of this stream, sorted according to the
   * provided {@code Comparator}.
   *
   * <p>
   * For ordered streams, the sort is stable. For unordered streams, no stability guarantees are
   * made.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @param comparator a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to be used
   *        to compare stream elements
   * @return the new stream
   * @see Stream#sorted(Comparator)
   */
  CheckedStream<T, X> sorted(Throwing.Comparator<? super T, ? extends X> comparator);

  /**
   * Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this
   * stream, using the provided identity value and an
   * <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns
   * the reduced value. This is equivalent to:
   *
   * <pre>
   * {@code
   *     T result = identity;
   *     for (T element : this stream)
   *         result = accumulator.apply(result, element)
   *     return result;
   * }
   * </pre>
   *
   * but is not constrained to execute sequentially.
   *
   * <p>
   * The {@code identity} value must be an identity for the accumulator function. This means that
   * for all {@code t}, {@code accumulator.apply(identity, t)} is equal to {@code t}. The
   * {@code accumulator} function must be an
   * <a href="package-summary.html#Associativity">associative</a> function.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @apiNote Sum, min, max, average, and string concatenation are all special cases of reduction.
   *          Summing a stream of numbers can be expressed as:
   *
   *          <pre>
   *          {@code
   *     Integer sum = integers.reduce(0, (a, b) -> a+b);
   * }
   *          </pre>
   *
   *          or:
   *
   *          <pre>
   *          {@code
   *     Integer sum = integers.reduce(0, Integer::sum);
   * }
   *          </pre>
   *
   *          <p>
   *          While this may seem a more roundabout way to perform an aggregation compared to simply
   *          mutating a running total in a loop, reduction operations parallelize more gracefully,
   *          without needing additional synchronization and with greatly reduced risk of data
   *          races.
   *
   * @param identity the identity value for the accumulating function
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for combining two
   *        values
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#reduce(Object, BinaryOperator) <code>Stream.reduce(T, BinaryOperator)</code>
   */
  T reduce(T identity, Throwing.BinaryOperator<T, ? extends X> accumulator) throws X;

  /**
   * Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this
   * stream, using an <a href="package-summary.html#Associativity">associative</a> accumulation
   * function, and returns an {@code Optional} describing the reduced value, if any. This is
   * equivalent to:
   *
   * <pre>
   * {@code
   *     boolean foundAny = false;
   *     T result = null;
   *     for (T element : this stream) {
   *         if (!foundAny) {
   *             foundAny = true;
   *             result = element;
   *         }
   *         else
   *             result = accumulator.apply(result, element);
   *     }
   *     return foundAny ? Optional.of(result) : Optional.empty();
   * }
   * </pre>
   *
   * but is not constrained to execute sequentially.
   *
   * <p>
   * The {@code accumulator} function must be an
   * <a href="package-summary.html#Associativity">associative</a> function.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for combining two
   *        values
   * @return an {@link Optional} describing the result of the reduction
   * @throws NullPointerException if the result of the reduction is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #reduce(Object, Throwing.BinaryOperator)
   * @see #min(Throwing.Comparator)
   * @see #max(Throwing.Comparator)
   * @see Stream#reduce(BinaryOperator)
   */
  Optional<T> reduce(Throwing.BinaryOperator<T, ? extends X> accumulator) throws X;

  /**
   * Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this
   * stream, using the provided identity, accumulation and combining functions. This is equivalent
   * to:
   *
   * <pre>
   * {@code
   *     U result = identity;
   *     for (T element : this stream)
   *         result = accumulator.apply(result, element)
   *     return result;
   * }
   * </pre>
   *
   * but is not constrained to execute sequentially.
   *
   * <p>
   * The {@code identity} value must be an identity for the combiner function. This means that for
   * all {@code u}, {@code combiner(identity, u)} is equal to {@code u}. Additionally, the
   * {@code combiner} function must be compatible with the {@code accumulator} function; for all
   * {@code u} and {@code t}, the following must hold:
   *
   * <pre>
   * {@code
   *     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
   * }
   * </pre>
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @apiNote Many reductions using this form can be represented more simply by an explicit
   *          combination of {@code map} and {@code reduce} operations. The {@code accumulator}
   *          function acts as a fused mapper and accumulator, which can sometimes be more efficient
   *          than separate mapping and reduction, such as when knowing the previously reduced value
   *          allows you to avoid some computation.
   *
   * @param <U> The type of the result
   * @param identity the identity value for the combiner function
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an
   *        additional element into a result
   * @param combiner an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for combining two
   *        values, which must be compatible with the accumulator function
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #reduce(Throwing.BinaryOperator)
   * @see #reduce(Object, Throwing.BinaryOperator)
   * @see Stream#reduce(Object, BiFunction, BinaryOperator)
   *      {@code Stream.reduce(U, BiFunction, BinaryOperator)}
   */
  <U> U reduce(U identity, Throwing.BiFunction<U, ? super T, U, ? extends X> accumulator,
      Throwing.BinaryOperator<U, ? extends X> combiner) throws X;

  /**
   * Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on
   * the elements of this stream. A mutable reduction is one in which the reduced value is a mutable
   * result container, such as an {@code ArrayList}, and elements are incorporated by updating the
   * state of the result rather than by replacing the result. This produces a result equivalent to:
   *
   * <pre>
   * {@code
   *     R result = supplier.get();
   *     for (T element : this stream)
   *         accumulator.accept(result, element);
   *     return result;
   * }
   * </pre>
   *
   * <p>
   * Like {@link #reduce(Object, Throwing.BinaryOperator)}, {@code collect} operations can be
   * parallelized without requiring additional synchronization.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @apiNote There are many existing classes in the JDK whose signatures are well-suited for use
   *          with method references as arguments to {@code collect()}. For example, the following
   *          will accumulate strings into an {@code ArrayList}:
   *
   *          <pre>
   *          {@code
   *     List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add,
   *                                                ArrayList::addAll);
   * }
   *          </pre>
   *
   *          <p>
   *          The following will take a stream of strings and concatenates them into a single
   *          string:
   *
   *          <pre>
   *          {@code
   *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,
   *                                          StringBuilder::append)
   *                                 .toString();
   * }
   *          </pre>
   *
   * @param <R> the type of the mutable result container
   * @param supplier a function that creates a new mutable result container. For a parallel
   *        execution, this function may be called multiple times and must return a fresh value each
   *        time.
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function that must fold an
   *        element into a result container.
   * @param combiner an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function that accepts two
   *        partial result containers and merges them, which must be compatible with the accumulator
   *        function. The combiner function must fold the elements from the second result container
   *        into the first result container.
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#collect(Supplier, BiConsumer, BiConsumer)
   */
  <R> R collect(Throwing.Supplier<R, ? extends X> supplier,
      Throwing.BiConsumer<R, ? super T, ? extends X> accumulator,
      Throwing.BiConsumer<R, R, ? extends X> combiner) throws X;

  /**
   * Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on
   * the elements of this stream using a {@code Collector}. A {@code Collector} encapsulates the
   * functions used as arguments to
   * {@link #collect(Throwing.Supplier, Throwing.BiConsumer, Throwing.BiConsumer)}, allowing for
   * reuse of collection strategies and composition of collect operations such as multiple-level
   * grouping or partitioning.
   *
   * <p>
   * If the stream is parallel, and the {@code Collector} is
   * {@link Collector.Characteristics#CONCURRENT concurrent}, and either the stream is unordered or
   * the collector is {@link Collector.Characteristics#UNORDERED unordered}, then a concurrent
   * reduction will be performed (see {@link Collector} for details on concurrent reduction.)
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * <p>
   * When executed in parallel, multiple intermediate results may be instantiated, populated, and
   * merged so as to maintain isolation of mutable data structures. Therefore, even when executed in
   * parallel with non-thread-safe data structures (such as {@code ArrayList}), no additional
   * synchronization is needed for a parallel reduction.
   *
   * @apiNote The following will accumulate strings into an ArrayList:
   *
   *          <pre>
   *          {@code
   *     List<String> asList = stringStream.collect(Collectors.toList());
   * }
   *          </pre>
   *
   *          <p>
   *          The following will classify {@code Person} objects by city:
   *
   *          <pre>
   *          {@code
   *     Map<String, List<Person>> peopleByCity
   *         = personStream.collect(Collectors.groupingBy(Person::getCity));
   * }
   *          </pre>
   *
   *          <p>
   *          The following will classify {@code Person} objects by state and city, cascading two
   *          {@code Collector}s together:
   *
   *          <pre>
   *          {@code
   *     Map<String, Map<String, List<Person>>> peopleByStateAndCity
   *         = personStream.collect(Collectors.groupingBy(Person::getState,
   *                                                      Collectors.groupingBy(Person::getCity)));
   * }
   *          </pre>
   *
   * @param <R> the type of the result
   * @param <A> the intermediate accumulation type of the {@code Collector}
   * @param collector the {@code Collector} describing the reduction
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #collect(Throwing.Supplier, Throwing.BiConsumer, Throwing.BiConsumer)
   * @see Collectors
   * @see Stream#collect(Collector)
   */
  <R, A> R collect(Collector<? super T, A, R> collector) throws X;

  /**
   * Returns whether all elements of this stream match the provided predicate. May not evaluate the
   * predicate on all elements if not necessary for determining the result. If the stream is empty
   * then {@code true} is returned and the predicate is not evaluated.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @apiNote This method evaluates the <em>universal quantification</em> of the predicate over the
   *          elements of the stream (for all x P(x)). If the stream is empty, the quantification is
   *          said to be <em>vacuously satisfied</em> and is always {@code true} (regardless of
   *          P(x)).
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements of this stream
   * @return {@code true} if either all elements of the stream match the provided predicate or the
   *         stream is empty, otherwise {@code false}
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#allMatch(Predicate)
   */
  boolean allMatch(Throwing.Predicate<? super T, ? extends X> predicate) throws X;

  /**
   * Returns whether any elements of this stream match the provided predicate. May not evaluate the
   * predicate on all elements if not necessary for determining the result. If the stream is empty
   * then {@code false} is returned and the predicate is not evaluated.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @apiNote This method evaluates the <em>existential quantification</em> of the predicate over
   *          the elements of the stream (for some x P(x)).
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements of this stream
   * @return {@code true} if any elements of the stream match the provided predicate, otherwise
   *         {@code false}
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#anyMatch(Predicate)
   */
  boolean anyMatch(Throwing.Predicate<? super T, ? extends X> predicate) throws X;

  /**
   * Returns whether no elements of this stream match the provided predicate. May not evaluate the
   * predicate on all elements if not necessary for determining the result. If the stream is empty
   * then {@code true} is returned and the predicate is not evaluated.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @apiNote This method evaluates the <em>universal quantification</em> of the negated predicate
   *          over the elements of the stream (for all x ~P(x)). If the stream is empty, the
   *          quantification is said to be vacuously satisfied and is always {@code true},
   *          regardless of P(x).
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements of this stream
   * @return {@code true} if either no elements of the stream match the provided predicate or the
   *         stream is empty, otherwise {@code false}
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#noneMatch(Predicate)
   */
  boolean noneMatch(Throwing.Predicate<? super T, ? extends X> predicate) throws X;

  /**
   * Returns a stream consisting of the elements of this stream, additionally performing the
   * provided action on each element as elements are consumed from the resulting stream.
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * <p>
   * For parallel stream pipelines, the action may be called at whatever time and in whatever thread
   * the element is made available by the upstream operation. If the action modifies shared state,
   * it is responsible for providing the required synchronization.
   *
   * @apiNote This method exists mainly to support debugging, where you want to see the elements as
   *          they flow past a certain point in a pipeline:
   *
   *          <pre>
   *          {@code
   * Stream<String> s = Stream.of("one", "two", "three", "four");
   * s.filter(e -> e.length() > 3)
   *     .peek(e -> System.out.println("Filtered value: " + e))
   *     .map(String::toUpperCase)
   *     .peek(e -> System.out.println("Mapped value: " + e))
   *     .collect(Collectors.toList());
   * }
   *          </pre>
   *
   *          <p>
   *          In cases where the stream implementation is able to optimize away the production of
   *          some or all the elements (such as with short-circuiting operations like
   *          {@code findFirst}, or in the example described in {@link #count}), the action will not
   *          be invoked for those elements.
   *
   * @param action a <a href="package-summary.html#NonInterference"> non-interfering</a> action to
   *        perform on the elements as they are consumed from the stream
   * @return the new stream
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#peek(Consumer)
   */
  CheckedStream<T, X> peek(Throwing.Consumer<? super T, ? extends X> action) throws X;

  /**
   * Returns the count of elements in this stream. This is a special case of a
   * <a href="package-summary.html#Reduction">reduction</a> and is equivalent to:
   *
   * <pre>
   * {@code
   *     return mapToLong(e -> 1L).sum();
   * }
   * </pre>
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @apiNote An implementation may choose to not execute the stream pipeline (either sequentially
   *          or in parallel) if it is capable of computing the count directly from the stream
   *          source. In such cases no source elements will be traversed and no intermediate
   *          operations will be evaluated. Behavioral parameters with side-effects, which are
   *          strongly discouraged except for harmless cases such as debugging, may be affected. For
   *          example, consider the following stream:
   *
   *          <pre>
   *          {@code
   *     List<String> l = Arrays.asList("A", "B", "C", "D");
   *     long count = l.stream().peek(System.out::println).count();
   * }
   *          </pre>
   *
   *          The number of elements covered by the stream source, a {@code List}, is known and the
   *          intermediate operation, {@code peek}, does not inject into or remove elements from the
   *          stream (as may be the case for {@code flatMap} or {@code filter} operations). Thus the
   *          count is the size of the {@code List} and there is no need to execute the pipeline
   *          and, as a side-effect, print out the list elements.
   *
   * @return the count of elements in this stream
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#count()
   */
  long count() throws X;

  /**
   * Returns an {@link Optional} describing some element of the stream, or an empty {@code Optional}
   * if the stream is empty.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * <p>
   * The behavior of this operation is explicitly nondeterministic; it is free to select any element
   * in the stream. This is to allow for maximal performance in parallel operations; the cost is
   * that multiple invocations on the same source may not return the same result. (If a stable
   * result is desired, use {@link #findFirst()} instead.)
   *
   * @return an {@code Optional} describing some element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the element selected is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #findFirst()
   * @see Stream#findAny()
   */
  Optional<T> findAny() throws X;

  /**
   * Returns an {@link Optional} describing the first element of this stream, or an empty
   * {@code Optional} if the stream is empty. If the stream has no encounter order, then any element
   * may be returned.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @return an {@code Optional} describing the first element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the element selected is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#findFirst()
   */
  Optional<T> findFirst() throws X;

  /**
   * Performs an action for each element of this stream.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * <p>
   * The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines,
   * this operation does <em>not</em> guarantee to respect the encounter order of the stream, as
   * doing so would sacrifice the benefit of parallelism. For any given element, the action may be
   * performed at whatever time and in whatever thread the library chooses. If the action accesses
   * shared state, it is responsible for providing the required synchronization.
   *
   * @param action a <a href="package-summary.html#NonInterference"> non-interfering</a> action to
   *        perform on the elements
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#forEach(Consumer)
   */
  void forEach(Throwing.Consumer<? super T, ? extends X> action) throws X;

  /**
   * Performs an action for each element of this stream, in the encounter order of the stream if the
   * stream has a defined encounter order.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * <p>
   * This operation processes the elements one at a time, in encounter order if one exists.
   * Performing the action for one element
   * <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
   * performing the action for subsequent elements, but for any given element, the action may be
   * performed in whatever thread the library chooses.
   *
   * @param action a <a href="package-summary.html#NonInterference"> non-interfering</a> action to
   *        perform on the elements
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #forEach(Throwing.Consumer)
   * @see Stream#forEachOrdered(Consumer)
   */
  void forEachOrdered(Throwing.Consumer<? super T, ? extends X> action) throws X;

  /**
   * Returns the maximum element of this stream according to the provided {@code Comparator}. This
   * is a special case of a <a href="package-summary.html#Reduction">reduction</a>.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param comparator a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to compare
   *        elements of this stream
   * @return an {@code Optional} describing the maximum element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the maximum element is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#max(Comparator)
   */
  Optional<T> max(Throwing.Comparator<? super T, ? extends X> comparator) throws X;

  /**
   * Returns the minimum element of this stream according to the provided {@code Comparator}. This
   * is a special case of a <a href="package-summary.html#Reduction">reduction</a>.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param comparator a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to compare
   *        elements of this stream
   * @return an {@code Optional} describing the minimum element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the minimum element is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#min(Comparator)
   */
  Optional<T> min(Throwing.Comparator<? super T, ? extends X> comparator) throws X;

  /**
   * Accumulates the elements of this stream into an immutable list.
   *
   * @return an immutable list
   * @throws X if any functional interface operating on this stream throws a checked exception
   */
  ImmutableList<T> toList() throws X;
}
