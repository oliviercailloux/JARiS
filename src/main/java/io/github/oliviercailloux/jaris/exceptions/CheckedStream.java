package io.github.oliviercailloux.jaris.exceptions;

import com.google.common.collect.ImmutableList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * An equivalent to Java {@link Stream} which allows for functional interfaces that may throw
 * checked exceptions; designed for people who do not like sneaky-throws.
 * <p>
 * The following popular SO questions mention several libraries that deal with the “streams and
 * checked exceptions” issue, but (at the time of writing) every library that I found there sneaky
 * throw, apart from
 * <a href= "https://github.com/JeffreyFalgout/ThrowingStream/">ThrowingStream</a>.
 * </p>
 * <ul>
 * <li><a href="https://stackoverflow.com/questions/23548589">Java 8: How do I work with exception
 * throwing methods in streams?</a></li>
 * <li><a href="https://stackoverflow.com/questions/19757300">Java 8: Lambda-Streams, Filter by
 * Method with Exception</a></li>
 * <li><a href="https://stackoverflow.com/questions/30117134">Aggregate runtime exceptions in Java 8
 * streams</a></li>
 * <li><a href="https://stackoverflow.com/questions/27644361">How can I throw CHECKED exceptions
 * from inside Java 8 streams?</a></li>
 * </ul>
 * <p>
 * This approach is heavily inspired by
 * <a href= "https://github.com/JeffreyFalgout/ThrowingStream/">ThrowingStream</a>; some differences
 * are discussed <a href="https://github.com/JeffreyFalgout/ThrowingStream/issues/3">here</a>.
 * </p>
 * <p>
 * The Javadoc for the methods that are also present in {@code Stream} (that is, most methods of
 * this class) has been copied from the {@code Stream} analog, with minor modifications.
 * </p>
 *
 * @param <T> the type of the stream elements
 * @param <X> an exception type that functionals used with this stream may throw, and that terminal
 *        operations on this stream may throw
 * @see Stream
 */
public interface CheckedStream<T, X extends Exception> {

  /**
   * Returns a checked stream wrapping the given stream.
   * <p>
   * The returned stream will behave as the delegate one except that it accepts functionals that
   * declare checked exceptions. The returned stream throws, on terminal operations, any exception
   * thrown by a functional operation during the stream operations.
   * </p>
   *
   * @param <T> the type of the stream elements
   * @param <X> an exception type that functionals used with the returned stream may throw, and
   *        therefore, that terminal operations on the returned stream may throw
   * @param delegate the stream executing operations
   * @return a checked stream delegating to the given stream
   */
  public static <T, X extends Exception> CheckedStream<T, X> wrapping(Stream<T> delegate) {
    return CheckedStreamImpl.wrapping(delegate);
  }

  /**
   * Returns a checked stream wrapping the stream produced by {@code collection.stream()}.
   * <p>
   * The returned stream will behave as the delegate one except that it accepts functionals that
   * declare checked exceptions. The returned stream throws, on terminal operations, any exception
   * thrown by a functional operation during the stream operations.
   * </p>
   *
   * @param <T> the type of the stream elements
   * @param <X> an exception type that functionals used with the returned stream may throw, and
   *        therefore, that terminal operations on the returned stream may throw
   * @param collection the source
   * @return a checked stream using the given collection as source
   */
  public static <T, X extends Exception> CheckedStream<T, X> from(Collection<T> collection) {
    return wrapping(collection.stream());
  }

  /**
   * Returns an infinite sequential unordered checked stream where each element is generated by the
   * provided {@code Throwing.Supplier}. This is suitable for generating constant streams, streams
   * of random elements, etc.
   * <p>
   * The returned stream accepts functionals that declare checked exceptions. The returned stream
   * throws, on terminal operations, any exception thrown by a functional operation during the
   * stream operations (including by the given generator).
   * </p>
   *
   * @param <T> the type of stream elements
   * @param <X> an exception type that functionals used with the returned stream may throw, and
   *        therefore, that terminal operations on the returned stream may throw
   * @param generator the {@code Throwing.Supplier} of generated elements
   * @return a new infinite sequential unordered {@code CheckedStream}
   * @see Stream#generate(Supplier)
   */
  public static <T, X extends Exception> CheckedStream<T, X>
      generate(Throwing.Supplier<? extends T, ? extends X> generator) {
    return CheckedStreamImpl.generate(generator);
  }

  /**
   * Returns a checked stream consisting of the distinct elements (according to
   * {@link Object#equals(Object)}) of this stream.
   *
   * <p>
   * For ordered streams, the selection of distinct elements is stable (for duplicated elements, the
   * element appearing first in the encounter order is preserved.) For unordered streams, no
   * stability guarantees are made.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @return the new stream
   * @see Stream#distinct()
   */
  CheckedStream<T, X> distinct();

  /**
   * Returns, if this stream is ordered, a checked stream consisting of the remaining elements of
   * this stream after dropping the longest prefix of elements that match the given predicate.
   * Otherwise returns, if this stream is unordered, a stream consisting of the remaining elements
   * of this stream after dropping a subset of elements that match the given predicate.
   *
   * <p>
   * If this stream is ordered then the longest prefix is a contiguous sequence of elements of this
   * stream that match the given predicate. The first element of the sequence is the first element
   * of this stream, and the element immediately following the last element of the sequence does not
   * match the given predicate.
   *
   * <p>
   * If this stream is unordered, and some (but not all) elements of this stream match the given
   * predicate, then the behavior of this operation is nondeterministic; it is free to drop any
   * subset of matching elements (which includes the empty set).
   *
   * <p>
   * Independent of whether this stream is ordered or unordered if all elements of this stream match
   * the given predicate then this operation drops all elements (the result is an empty stream), or
   * if no elements of the stream match the given predicate then no elements are dropped (the result
   * is the same as the input).
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements to determine the longest prefix of elements.
   * @return the new stream
   * @see Stream#dropWhile(Predicate)
   */
  CheckedStream<T, X> dropWhile(Throwing.Predicate<? super T, ? extends X> predicate);

  /**
   * Returns, if this stream is ordered, a checked stream consisting of the longest prefix of
   * elements taken from this stream that match the given predicate. Otherwise returns, if this
   * stream is unordered, a stream consisting of a subset of elements taken from this stream that
   * match the given predicate.
   *
   * <p>
   * If this stream is ordered then the longest prefix is a contiguous sequence of elements of this
   * stream that match the given predicate. The first element of the sequence is the first element
   * of this stream, and the element immediately following the last element of the sequence does not
   * match the given predicate.
   *
   * <p>
   * If this stream is unordered, and some (but not all) elements of this stream match the given
   * predicate, then the behavior of this operation is nondeterministic; it is free to take any
   * subset of matching elements (which includes the empty set).
   *
   * <p>
   * Independent of whether this stream is ordered or unordered if all elements of this stream match
   * the given predicate then this operation takes all elements (the result is the same as the
   * input), or if no elements of the stream match the given predicate then no elements are taken
   * (the result is an empty stream).
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate
   * operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements to determine the longest prefix of elements.
   * @return the new stream
   * @see Stream#takeWhile(Predicate)
   */
  CheckedStream<T, X> takeWhile(Throwing.Predicate<? super T, ? extends X> predicate);

  /**
   * Returns a checked stream consisting of the elements of this stream that match the given
   * predicate.
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to each
   *        element to determine if it should be included
   * @return the new stream
   * @see Stream#filter(Predicate)
   */
  CheckedStream<T, X> filter(Throwing.Predicate<? super T, ? extends X> predicate);

  /**
   * Returns a checked stream consisting of the results of replacing each element of this stream
   * with the contents of a mapped stream produced by applying the provided mapping function to each
   * element. Each mapped stream is {@link java.util.stream.BaseStream#close() closed} after its
   * contents have been placed into this stream. (If a mapped stream is {@code null} an empty stream
   * is used, instead.)
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * @param <R> The element type of the new stream
   * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function to apply to each
   *        element which produces a stream of new values
   * @return the new stream
   * @see Stream#flatMap(Function)
   */
  <R> CheckedStream<R, X>
      flatMap(Throwing.Function<? super T, ? extends Stream<? extends R>, ? extends X> mapper);

  /**
   * Returns a checked stream consisting of the elements of this stream, truncated to be no longer
   * than {@code maxSize} in length.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting stateful intermediate
   * operation</a>.
   *
   * @param maxSize the number of elements the stream should be limited to
   * @return the new stream
   * @throws IllegalArgumentException if {@code maxSize} is negative
   * @see Stream#limit(long)
   */
  CheckedStream<T, X> limit(long maxSize);

  /**
   * Returns a checked stream consisting of the results of applying the given function to the
   * elements of this stream.
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * @param <R> The element type of the new stream
   * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function to apply to each
   *        element
   * @return the new stream
   * @see Stream#map(Function)
   */
  <R> CheckedStream<R, X> map(Throwing.Function<? super T, ? extends R, ? extends X> mapper);

  /**
   * Returns a checked stream consisting of the remaining elements of this stream after discarding
   * the first {@code n} elements of the stream. If this stream contains fewer than {@code n}
   * elements then an empty stream will be returned.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @param n the number of leading elements to skip
   * @return the new stream
   * @throws IllegalArgumentException if {@code n} is negative
   * @see Stream#skip(long)
   */
  CheckedStream<T, X> skip(long n);

  /**
   * Returns a checked stream consisting of the elements of this stream, sorted according to natural
   * order. If the elements of this stream are not {@code Comparable}, a
   * {@code java.lang.ClassCastException} may be thrown when the terminal operation is executed.
   *
   * <p>
   * For ordered streams, the sort is stable. For unordered streams, no stability guarantees are
   * made.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @return the new stream
   * @see Stream#sorted()
   */
  CheckedStream<T, X> sorted();

  /**
   * Returns a checked stream consisting of the elements of this stream, sorted according to the
   * provided {@code Comparator}.
   *
   * <p>
   * For ordered streams, the sort is stable. For unordered streams, no stability guarantees are
   * made.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">stateful intermediate operation</a>.
   *
   * @param comparator a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to be used
   *        to compare stream elements
   * @return the new stream
   * @see Stream#sorted(Comparator)
   */
  CheckedStream<T, X> sorted(Throwing.Comparator<? super T, ? extends X> comparator);

  /**
   * Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this
   * stream, using the provided identity value and an
   * <a href="package-summary.html#Associativity">associative</a> accumulation function, and returns
   * the reduced value. This is equivalent to:
   *
   * <pre>
   * {@code
   *     T result = identity;
   *     for (T element : this stream)
   *         result = accumulator.apply(result, element)
   *     return result;
   * }
   * </pre>
   *
   * but is not constrained to execute sequentially.
   *
   * <p>
   * The {@code identity} value must be an identity for the accumulator function. This means that
   * for all {@code t}, {@code accumulator.apply(identity, t)} is equal to {@code t}. The
   * {@code accumulator} function must be an
   * <a href="package-summary.html#Associativity">associative</a> function.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param identity the identity value for the accumulating function
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for combining two
   *        values
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#reduce(Object, BinaryOperator) <code>Stream.reduce(T, BinaryOperator)</code>
   */
  T reduce(T identity, Throwing.BinaryOperator<T, ? extends X> accumulator) throws X;

  /**
   * Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this
   * stream, using an <a href="package-summary.html#Associativity">associative</a> accumulation
   * function, and returns an {@code Optional} describing the reduced value, if any. This is
   * equivalent to:
   *
   * <pre>
   * {@code
   *     boolean foundAny = false;
   *     T result = null;
   *     for (T element : this stream) {
   *         if (!foundAny) {
   *             foundAny = true;
   *             result = element;
   *         }
   *         else
   *             result = accumulator.apply(result, element);
   *     }
   *     return foundAny ? Optional.of(result) : Optional.empty();
   * }
   * </pre>
   *
   * but is not constrained to execute sequentially.
   *
   * <p>
   * The {@code accumulator} function must be an
   * <a href="package-summary.html#Associativity">associative</a> function.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for combining two
   *        values
   * @return an {@link Optional} describing the result of the reduction
   * @throws NullPointerException if the result of the reduction is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #reduce(Object, Throwing.BinaryOperator)
   * @see #min(Throwing.Comparator)
   * @see #max(Throwing.Comparator)
   * @see Stream#reduce(BinaryOperator)
   */
  Optional<T> reduce(Throwing.BinaryOperator<T, ? extends X> accumulator) throws X;

  /**
   * Performs a <a href="package-summary.html#Reduction">reduction</a> on the elements of this
   * stream, using the provided identity, accumulation and combining functions. This is equivalent
   * to:
   *
   * <pre>
   * {@code
   *     U result = identity;
   *     for (T element : this stream)
   *         result = accumulator.apply(result, element)
   *     return result;
   * }
   * </pre>
   *
   * but is not constrained to execute sequentially.
   *
   * <p>
   * The {@code identity} value must be an identity for the combiner function. This means that for
   * all {@code u}, {@code combiner(identity, u)} is equal to {@code u}. Additionally, the
   * {@code combiner} function must be compatible with the {@code accumulator} function; for all
   * {@code u} and {@code t}, the following must hold:
   *
   * <pre>
   * {@code
   *     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)
   * }
   * </pre>
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param <U> The type of the result
   * @param identity the identity value for the combiner function
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for incorporating an
   *        additional element into a result
   * @param combiner an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function for combining two
   *        values, which must be compatible with the accumulator function
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #reduce(Throwing.BinaryOperator)
   * @see #reduce(Object, Throwing.BinaryOperator)
   * @see Stream#reduce(Object, BiFunction, BinaryOperator)
   *      {@code Stream.reduce(U, BiFunction, BinaryOperator)}
   */
  <U> U reduce(U identity, Throwing.BiFunction<U, ? super T, U, ? extends X> accumulator,
      Throwing.BinaryOperator<U, ? extends X> combiner) throws X;

  /**
   * Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on
   * the elements of this stream. A mutable reduction is one in which the reduced value is a mutable
   * result container, such as an {@code ArrayList}, and elements are incorporated by updating the
   * state of the result rather than by replacing the result. This produces a result equivalent to:
   *
   * <pre>
   * {@code
   *     R result = supplier.get();
   *     for (T element : this stream)
   *         accumulator.accept(result, element);
   *     return result;
   * }
   * </pre>
   *
   * <p>
   * Like {@link #reduce(Object, Throwing.BinaryOperator)}, {@code collect} operations can be
   * parallelized without requiring additional synchronization.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param <R> the type of the mutable result container
   * @param supplier a function that creates a new mutable result container. For a parallel
   *        execution, this function may be called multiple times and must return a fresh value each
   *        time.
   * @param accumulator an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function that must fold an
   *        element into a result container.
   * @param combiner an <a href="package-summary.html#Associativity">associative</a>,
   *        <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> function that accepts two
   *        partial result containers and merges them, which must be compatible with the accumulator
   *        function. The combiner function must fold the elements from the second result container
   *        into the first result container.
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#collect(Supplier, BiConsumer, BiConsumer)
   */
  <R> R collect(Throwing.Supplier<R, ? extends X> supplier,
      Throwing.BiConsumer<R, ? super T, ? extends X> accumulator,
      Throwing.BiConsumer<R, R, ? extends X> combiner) throws X;

  /**
   * Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on
   * the elements of this stream using a {@code Collector}. A {@code Collector} encapsulates the
   * functions used as arguments to
   * {@link #collect(Throwing.Supplier, Throwing.BiConsumer, Throwing.BiConsumer)}, allowing for
   * reuse of collection strategies and composition of collect operations such as multiple-level
   * grouping or partitioning.
   *
   * <p>
   * If the stream is parallel, and the {@code Collector} is
   * {@link Collector.Characteristics#CONCURRENT concurrent}, and either the stream is unordered or
   * the collector is {@link Collector.Characteristics#UNORDERED unordered}, then a concurrent
   * reduction will be performed (see {@link Collector} for details on concurrent reduction.)
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * <p>
   * When executed in parallel, multiple intermediate results may be instantiated, populated, and
   * merged so as to maintain isolation of mutable data structures. Therefore, even when executed in
   * parallel with non-thread-safe data structures (such as {@code ArrayList}), no additional
   * synchronization is needed for a parallel reduction.
   *
   * @param <R> the type of the result
   * @param <A> the intermediate accumulation type of the {@code Collector}
   * @param collector the {@code Collector} describing the reduction
   * @return the result of the reduction
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #collect(Throwing.Supplier, Throwing.BiConsumer, Throwing.BiConsumer)
   * @see Collectors
   * @see Stream#collect(Collector)
   */
  <R, A> R collect(Collector<? super T, A, R> collector) throws X;

  /**
   * Returns whether all elements of this stream match the provided predicate. May not evaluate the
   * predicate on all elements if not necessary for determining the result. If the stream is empty
   * then {@code true} is returned and the predicate is not evaluated.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements of this stream
   * @return {@code true} if either all elements of the stream match the provided predicate or the
   *         stream is empty, otherwise {@code false}
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#allMatch(Predicate)
   */
  boolean allMatch(Throwing.Predicate<? super T, ? extends X> predicate) throws X;

  /**
   * Returns whether any elements of this stream match the provided predicate. May not evaluate the
   * predicate on all elements if not necessary for determining the result. If the stream is empty
   * then {@code false} is returned and the predicate is not evaluated.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements of this stream
   * @return {@code true} if any elements of the stream match the provided predicate, otherwise
   *         {@code false}
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#anyMatch(Predicate)
   */
  boolean anyMatch(Throwing.Predicate<? super T, ? extends X> predicate) throws X;

  /**
   * Returns whether no elements of this stream match the provided predicate. May not evaluate the
   * predicate on all elements if not necessary for determining the result. If the stream is empty
   * then {@code true} is returned and the predicate is not evaluated.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> predicate to apply to
   *        elements of this stream
   * @return {@code true} if either no elements of the stream match the provided predicate or the
   *         stream is empty, otherwise {@code false}
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#noneMatch(Predicate)
   */
  boolean noneMatch(Throwing.Predicate<? super T, ? extends X> predicate) throws X;

  /**
   * Returns a stream consisting of the elements of this stream, additionally performing the
   * provided action on each element as elements are consumed from the resulting stream.
   *
   * <p>
   * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
   *
   * <p>
   * For parallel stream pipelines, the action may be called at whatever time and in whatever thread
   * the element is made available by the upstream operation. If the action modifies shared state,
   * it is responsible for providing the required synchronization.
   *
   * @param action a <a href="package-summary.html#NonInterference"> non-interfering</a> action to
   *        perform on the elements as they are consumed from the stream
   * @return the new stream
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#peek(Consumer)
   */
  CheckedStream<T, X> peek(Throwing.Consumer<? super T, ? extends X> action) throws X;

  /**
   * Returns the count of elements in this stream. This is a special case of a
   * <a href="package-summary.html#Reduction">reduction</a> and is equivalent to:
   *
   * <pre>
   * {@code
   *     return mapToLong(e -> 1L).sum();
   * }
   * </pre>
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @return the count of elements in this stream
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#count()
   */
  long count() throws X;

  /**
   * Returns an {@link Optional} describing some element of the stream, or an empty {@code Optional}
   * if the stream is empty.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * <p>
   * The behavior of this operation is explicitly nondeterministic; it is free to select any element
   * in the stream. This is to allow for maximal performance in parallel operations; the cost is
   * that multiple invocations on the same source may not return the same result. (If a stable
   * result is desired, use {@link #findFirst()} instead.)
   *
   * @return an {@code Optional} describing some element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the element selected is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #findFirst()
   * @see Stream#findAny()
   */
  Optional<T> findAny() throws X;

  /**
   * Returns an {@link Optional} describing the first element of this stream, or an empty
   * {@code Optional} if the stream is empty. If the stream has no encounter order, then any element
   * may be returned.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">short-circuiting terminal operation</a>.
   *
   * @return an {@code Optional} describing the first element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the element selected is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#findFirst()
   */
  Optional<T> findFirst() throws X;

  /**
   * Performs an action for each element of this stream.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * <p>
   * The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines,
   * this operation does <em>not</em> guarantee to respect the encounter order of the stream, as
   * doing so would sacrifice the benefit of parallelism. For any given element, the action may be
   * performed at whatever time and in whatever thread the library chooses. If the action accesses
   * shared state, it is responsible for providing the required synchronization.
   *
   * @param action a <a href="package-summary.html#NonInterference"> non-interfering</a> action to
   *        perform on the elements
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#forEach(Consumer)
   */
  void forEach(Throwing.Consumer<? super T, ? extends X> action) throws X;

  /**
   * Performs an action for each element of this stream, in the encounter order of the stream if the
   * stream has a defined encounter order.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * <p>
   * This operation processes the elements one at a time, in encounter order if one exists.
   * Performing the action for one element
   * <a href="../concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
   * performing the action for subsequent elements, but for any given element, the action may be
   * performed in whatever thread the library chooses.
   *
   * @param action a <a href="package-summary.html#NonInterference"> non-interfering</a> action to
   *        perform on the elements
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see #forEach(Throwing.Consumer)
   * @see Stream#forEachOrdered(Consumer)
   */
  void forEachOrdered(Throwing.Consumer<? super T, ? extends X> action) throws X;

  /**
   * Returns the maximum element of this stream according to the provided {@code Comparator}. This
   * is a special case of a <a href="package-summary.html#Reduction">reduction</a>.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   *
   * @param comparator a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to compare
   *        elements of this stream
   * @return an {@code Optional} describing the maximum element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the maximum element is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#max(Comparator)
   */
  Optional<T> max(Throwing.Comparator<? super T, ? extends X> comparator) throws X;

  /**
   * Returns the minimum element of this stream according to the provided {@code Comparator}. This
   * is a special case of a <a href="package-summary.html#Reduction">reduction</a>.
   *
   * <p>
   * This is a <a href="package-summary.html#StreamOps">terminal operation</a>.
   * <p>
   * TODO think about returning a CheckedOptional, or TryOptional, that allows for an extended Map
   * operation.
   *
   * @param comparator a <a href="package-summary.html#NonInterference">non-interfering</a>,
   *        <a href="package-summary.html#Statelessness">stateless</a> {@code Comparator} to compare
   *        elements of this stream
   * @return an {@code Optional} describing the minimum element of this stream, or an empty
   *         {@code Optional} if the stream is empty
   * @throws NullPointerException if the minimum element is null
   * @throws X if any functional interface operating on this stream throws a checked exception
   * @see Stream#min(Comparator)
   */
  Optional<T> min(Throwing.Comparator<? super T, ? extends X> comparator) throws X;

  /**
   * Accumulates the elements of this stream into an immutable list.
   *
   * @return an immutable list
   * @throws X if any functional interface operating on this stream throws a checked exception
   */
  ImmutableList<T> toList() throws X;
}
